\documentclass{article}
\usepackage[top=2cm, left=2cm, right=2cm, bottom=3cm]{geometry}
\usepackage{lipsum} % untuk \lipsum
% terkait link/hyperlink
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=blue % bisa juga misalnya cyan
}

\title{\textit{Lessons Learned}, Proyek Mata Kuliah Pemrograman Fungsional: \\
\textit{Human Task Scheduler} dengan Metaheuristik Algoritma Genetika di Haskell}
\author{Tim/Kelompok: satu orang (individu) \\
Bisma Rohpanca Joyosumarto (2106635581)}
\date{Desember 2024}

\begin{document}

\maketitle

\noindent
\textbf{URL-Repository:} \url{https://github.com/BismaBRJ/human-task-scheduler-genetic-algo-hs} \\[0.5em]

%\lipsum

Sebelumnya, saya amat sangat berterima kasih atas kesempatan yang telah diberikan oleh Pak Ade agar saya dan teman saya Fritz, mahasiswa satu program studi dari luar Fasilkom UI, dapat merasakan perkulian \textit{Functional Programming} (FunPro) atau Pemrograman Fungsional (PemFung) pada semester ini. Apalagi, tugas akhir saya terkait \textit{proof verification} pada akhirnya memanfaatkan konsep \textit{type class} (seperti \href{https://lean-lang.org/theorem_proving_in_lean4/type_classes.html}{digunakan di \textit{Lean proof assistant}}) yang dipelajari di kuliah FunPro, sehingga saya sangat terbantu oleh mata kuliah ini.

Sebagai mahasiswa prodi S1 Matematika, saya sudah cukup familiar dengan salah satu sifat fungsi matematis yang kami sebut \textit{well-defined}. Artinya, input yang sama pasti dipetakan ke \textit{output} yang sama. Di dunia pemrograman fungsional, fungsi dengan sifat seperti itu dikenal sebagai fungsi yang tidak memiliki \textit{side effects}. Bahasa pemrograman yang bersifat \textit{purely functional}, seperti Haskell, menghendaki semua fungsi agar bersifat demikian. Sebagaimana telah dijelaskan selama perkuliahan FunPro ini, pendekatan seperti itu dapat mencegah berbagai masalah yang berkaitan dengan \textit{state}, atau lebih tepatnya \textit{mutable state}.

Oleh karena itu, saya terinspirasi untuk mencoba menerapkan pola berpikir fungsional dalam menyusun program, bahwa tiap program terdiri dari penerapan fungsi dengan berbagai pola fungsional, tiap fungsi berupa \textit{pure function} yaitu tanpa \textit{side effects}. Selain karena terbiasa dengan fungsi yang bersifat \textit{well-defined}, saya juga tertarik dengan penyusunan program yang tidak rentan terkena masalah yang berkaitan dengan \textit{state}. Memanfaatkan kesempatan proyek ini untuk mencoba membuat program yang sekiranya bermanfaat (sekaligus mengembangkan portofolio), saya pada akhirnya mencoba membuat suatu \textit{web app} (berupa \textit{static webpage}) yang saya beri nama \textit{Human Task Scheduler}. Pengguna bisa memasukkan jam kerja \textit{(work hours)} atau kalendar kerja, jam penuh \textit{(full hours)} di kalendar tersebut, dan tugas-tugas yang dimiliki (termasuk keterangan seperti \textit{deadline}). Program kemudian menjadwalkan kapan sebaiknya tugas-tugas tersebut dikerjakan, terutama agar tidak lewat \textit{deadline}, tetapi juga memperhatikan beberapa hal lainnya seperti kenyamanan, agar jadwal yang dihasilkan masih cukup manusiawi. Tujuan akhirnya adalah agar saya sendiri dan juga banyak orang lainnya bisa menggunakan aplikasi ini dan terbantu dalam penjadwalan kegiatan sehari-hari.

Meskipun proyek ini masih jauh dari kata sempurna, melalui proyek ini, saya telah mempelajari banyak hal seputar pengembangan aplikasi dan terlebih lagi tentang pemrograman fungsional. Dengan tekad membuat program tanpa masalah yang berkaitan dengan \textit{state}, saya membuat aplikasi ini sepenuhnya menggunakan bahasa pemrograman Haskell. Sebagai aplikasi penjadwalan, tentu pengguna perlu bisa memasukkan data-data yang diperlukan dan juga membaca jadwal yang dihasilkan. Sehingga, aplikasi yang saya buat terdiri dari \textit{backend} yaitu kode utama terkait teknis penjadwalan, dan juga \textit{frontend} yaitu kode untuk tampilan agar aplikasi bisa digunakan. Membuat \textit{backend} dengan Haskell sudah menjadi hal yang cukup lumrah, tetapi sekaligus membuat \textit{frontend} dengan Haskell adalah tantangan lebih yang tidak banyak dihadapi orang, dan ternyata memanfaatkan beberapa aspek pemrograman fungsional yang lebih lanjut, sebagian tidak saya sangka sebelumnya.

Hal pertama yang saya pelajari adalah terkait penyusunan struktur data, terutama betapa \textbf{pentingnya \textit{readability}}. Sebelum data seperti jam kerja dan tugas bisa diinput, tentu harus ada struktur datanya terlebih dahulu, agar format input bisa konsisten. Saya merepresentasikan hari ataupun jam sebagai bilangan bulat (positif), \textit{deadline} adalah sepasang hari dan jam, dan jadwal adalah sekumpulan \textit{(list)} pasangan hari-jam. Semuanya berupa bilangan atau sepasang bilangan atau sekumpulan bilangan. Apabila saya tulis semua tipenya dengan tipe bilangan bulat (\verb|Int|) begitu saja, program akan sulit dibaca karena saya perlu membedakan antara hari, jam, \textit{deadline}, jadwal, dan sebagainya, sehingga program akan sulit dikembangkan dan sulit diperbaiki apabila ada semacam kesalahan (hasil tidak sesuai harapan). Oleh karena itu, saya memanfaatkan fitur \textit{type alias;} saya membuat tipe data hari, jam, \textit{deadline}, jadwal, dan sebagainya, bahkan membedakan antara tipe data jam kerja (kalendar) dan tipe data jam penuh. Saya merasakan manfaatnya ketika mulai menulis fungsi-fungsi seputar data tersebut: tipenya jelas, kegunaan dan penggunaannya menjadi jelas hanya dari melihat \textit{type signature}-nya. Kode juga menjadi \textit{readable} atau bisa dibaca dengan baik oleh manusia, sehingga tidak begitu sulit bagi saya untuk memodifikasi fungsi yang dibuat apabila dibutuhkan.

Hal kedua yang saya pelajari adalah terkait \verb|Maybe|, cara \textbf{menangani ketiadaan data}. Terkadang, bahkan di aplikasi penjadwalan saya, walaupun pada awalnya tidak \textit{obvious} terlihat, saya temukan bahwa tipe \verb|Maybe| dibutuhkan ketika kapanpun ada keraguan tentang apakah suatu fungsi selalu bisa menghasilkan nilai yang jelas. Misalnya, dalam skema penjadwalan sederhana yang telah saya buat yaitu secara \textit{greedy}, tugas dengan \textit{deadline} terdekat dikerjakan terlebih dahulu, diikuti dengan tugas dengan \textit{deadline} kedua terdekat, dan sebagainya. Ini adalah cara yang paling menjamin selesainya semua tugas sebelum \textit{deadline}, walaupun mengorbankan sisi manusiawi seperti istirahat antar pengerjaan tugas dan sebagainya (untuk dipertimbangkan kemudian). Saya temukan bahwa cara termudah untuk melakukan ini adalah pertama memetakan semua jam kosong ke konsep jadwal lain yang mengabaikan semua jam penuh, lalu menjadwalkan pengerjaan semu tugas di konep jadwal tersebut dengan memanfaatkan \textit{sorting} berdasarkan \textit{deadline}, barulah memetakan kembali jam-jam pengerjaan tersebut ke jadwal kerja atau kalendar aslinya. Ini mungkin mirip dengan konsep \textit{memory mapping} dan/atau \textit{virtual memory} dalam sistem operasi, terkait alokasi memori. Ternyata, untuk memetakan ke konsep jadwal tanpa jam penuh tersebut, tentunya jam penuh tidak bisa dipetakan. Sehingga, hasil peta untuk jam penuh harus dibuat menjadi \verb|Nothing|. Dengan demikian, menjadi jelas kapan pemetaan tersebut memiliki nilai (harus digunakan \verb|Just| dari tipe data \verb|Maybe|), dan kapan pemetaan tersebut tidak memiliki nilai. Kejelasan adalah hal yang penting, tidak hanya dalam pemrograman fungsional, tetapi dalam pemrograman dan pengembangan aplikasi secara umum.

Hal ketiga yang saya pelajari adalah tentang \textbf{\textit{higher-order function}}, yang memang sering menjadi pembahasan di ranah pemrograman fungsional. Lagi-lagi, saya temukan penggunaan \textit{higher-order function} yang tidak saya sangka sebelumnya, yang pada awalnya tidak terlihat \textit{obvious}. Pemetaan yang dibahas di paragraf sebelumnya itu perlu diterapkan untuk tiap jam kosong yang ada. Apabila diterapkan secara langsung, komputasi akan cukup mahal karena pemetaan akan dihitung ulang atau dikonstruksi/dikomputasi ulang untuk tiap penerapan pada jam kosong, karena jadwal yang berbeda melibatkan pemetaan yang berbeda. Oleh karena itu, saya menyusun program sedemikian rupa sehingga pemetaan dihitung/disusun sekali saja "di awal", dengan input jadwal yang diberikan; barulah kemudian pemetaan yang sudah dimiliki itu bisa digunakan berkali-kali tanpa perlu dihitung ulang dari awal. Perhitungan di awal itu menghasilkan suatu pemetaan atau fungsi, yaitu mengembalikan suatu fungsi. Sehingga, fungsi yang menghasilkan pemetaan tersebut ternyata harus berupa \textit{higher-order function}. Ternyata penggunaan konsep \textit{higher-order function} tidak hanya untuk mempermudah pemrograman dalam berbagai konteks, tetapi juga bisa misalnya untuk menghemat komputasi, sebagaimana yang saya lakukan.

Hal keempat yang saya pelajari adalah bagaimana \textbf{urusan \textit{state} dalam \textit{frontend} berbasis fungsional}. Dalam Haskell, tersedia segelintir \textit{framework} untuk menyusun \textit{frontend}, seperti Reflex Platform yang saya pilih untuk proyek ini, atau biasa disebut Reflex. Kebetulan, selain pemrograman fungsional, Reflex lebih tepatnya menganut paradigma pemrograman yang disebut \textit{functional reactive programming} (FRP). Intinya, menjunjung tinggi pemrograman fungsional, \textit{state} (seperti isi suatu \textit{text box}) dianggap sebagai input dan tampilan yang dihasilkan menjadi \textit{output}, dengan input yang sama akan selalu menghasilkan \textit{output} atau tampilan yang sama; dan pembaruan tampilan dilakukan secara reaktif: tiap kali ada perubahan dalam \textit{state} (yaitu input), tampilan langsung dikomputasi ulang agar \textit{output} menjadi sesuai dengan \textit{input}. Hasilnya adalah \textit{web app} yang cepat merespon terhadap apapun input yang diberikan ataupun perubahan input yang terjadi, sepertinya juga memanfaatkan fitur optimisasi dari bahasa pemrograman Haskell yang bersifat \textit{compiled}.

Tidak jauh dari itu, konsep \textbf{\textit{functor} dan monad} sebagai cara mengakali ketiadaan \textit{state} dalam pemrograman fungsional juga saya gunakan. Untuk apapun \textit{widget} atau tampilan yang bisa berubah, Reflex memiliki semacam struktur data \textit{wrapper} yang disebut \verb|Dynamic|, mengandung data yang bisa diubah (baik berupa input seperti \textit{text box} ataupun berupa \textit{output} seperti \textit{text}) tergantung input yang bersesuaian. Karena dibungkus dalam \verb|Dynamic|, semua pengoperasian dengan data tersebut, seperti membaca nilainya, menghitung dengannya, hingga mengubah nilainya, perlu dilakukan secara tidak langsung melalui operasi-operasi \textit{applicative functor}. Artinya, fitur-fitur pemrograman fungsional seperti \textit{functor}, yang awalnya terkesan "jarang digunakan" atau bahkan "terlalu sulit", ternyata juga saya gunakan dan penggunaannya juga masuk akal dan intuitif; tidak ada kesan keterpaksaan.

Dari semua hal yang saya pelajari, saya menyimpulkan bahwa konsep-konsep pemrograman fungsional banyak membawa manfaat dan memang berguna, walaupun pada awalnya tidak jelas kegunaannya ataupun berasa "hanya digunakan untuk itu-itu saja". Ini telah membuka mata saya terkait pemrograman fungsional, bahwa penggunaan konsep-konsep yang dipelajari bisa jauh lebih luas daripada contoh kasus yang dipelajari di kelas, dan tentang betapa bermanfaatnya pemrograman fungsional.

Sebenarnya ada satu hal lagi yang saya pelajari, yaitu bahwa bahasa pemrograman yang \textit{purely functional} seperti Haskell memang \textbf{kurang digunakan secara umum}, apalagi untuk menyusun \textit{web app}, yang memiliki \textit{frontend}. Hal ini saya temukan terutama ketika sedang mempelajari fitur-fitur \textit{framework} bernama Reflex Platform untuk menyusun \textit{frontend} dalam Haskell. Menurut saya, kurangnya penggunaan Haskell adalah hal yang amat sangat disayangkan, karena, sifat \textit{purely functional} yang menghindari \textit{state} agar tidak muncul masalah terkait, adalah poin plus yang sangat; tentunya, musuh semua \textit{developer} adalah \textit{bugs} ataupun \textit{error}, dan tentunya juga, semakin banyak \textit{error} yang bisa dihindari (misalnya mencegah \textit{error} yang berkaitan dengan \textit{state}), semakin baik.

Setelah satu semester menjalani kuliah FunPro, dan bahkan sudah mulai saya rasakan, saya lebih \textit{aware} tentang berbagai pendekatan yang mungkin untuk menyelesaikan masalah, terutama yang berkaitan dengan pemrograman. Kini, saya yakin bahwa pendekatan imperatif, \textit{object-oriented}, dan fungsional memiliki kelebihan, kegunaan, dan tempatnya masing-masing. Dalam urusan pemrograman sehari-hari, saya terkadang memanfaatkan paradigma imperatif sederhana, terkadang merasa perlu konsep abstraksi yang ditawarkan oleh pendekatan \textit{object-oriented}, dan terkadang perlu jaminan \textit{well-defined} atau juga disebut \textit{referential transparency} yang diberikan oleh pendekatan fungsional. Atas terbukanya mata saya, dan atas semua \textit{insight} yang telah diberikan oleh Pak Ade baik secara langsung maupun tidak langsung melalui kuliah FunPro ini, saya ucapkan terima kasih banyak yang sebesar-besarnya, dan saya memohon maaf atas segala kekurangan saya selama satu semester ini. Sekali lagi terima kasih, dan semoga bisa bertemu kembali di kesempatan lain di masa depan, entah terkait pemrograman fungsional atau \textit{proof verification} atau lainnya.

\end{document}